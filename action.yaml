---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# python-build-action
name: '🐍 Build Python Project'
description: 'Builds a Python Project'

inputs:
  # Optional
  artefact_path:
    description: 'Build artefacts will be output to this folder/directory'
    required: false
    # type: string
    default: 'dist'
  artefact_upload:
    description: 'Upload artefacts to GitHub once build completed'
    required: false
    # type: boolean
    default: 'true'
  purge_artefact_path:
    description: 'Purge artefact path prior to performing build'
    required: false
    # type: boolean
    default: 'false'
  tag:
    description: 'Explicit tag/version for this build (semantic)'
    required: false
    # type: string
  skip_version_patch:
    description: 'Skip version patching (support dynamic versioning)'
    required: false
    # type: boolean
    default: 'false'
  attestations:
    # Attestations should NOT be enabled for development builds
    description: 'Apply GitHub attestations to artefacts'
    required: false
    # type: boolean
    default: 'false'
  sigstore_sign:
    # Signing should NOT be enabled for development builds
    description: 'Sign build artefacts with Sigstore'
    required: false
    # type: boolean
    default: 'false'
  path_prefix:
    description: 'Directory location containing project code'
    required: false
    # type: string
    default: '.'
  tox_build:
    description: 'Attempt to use TOX to perform build'
    required: false
    # type: boolean
    default: 'false'

outputs:
  build_python_version:
    description: 'Python version used to perform build (create artefacts)'
    value: "${{ steps.python-metadata.outputs.build_python_version }}"
  matrix_json:
    description: 'Project supported Python versions as JSON'
    value: ${{ steps.python-metadata.outputs.matrix_json }}
  artefact_name:
    description: 'Build artefacts will be output to this folder/directory'
    value: ${{ steps.python-metadata.outputs.python_project_name }}
  artefact_path:
    description: 'Build artefacts will be output to this folder/directory'
    value: ${{ inputs.artefact_path }}

runs:
  using: 'composite'
  steps:
    - name: 'Setup action/environment'
      shell: bash
      env:
        INPUT_PATH_PREFIX: ${{ inputs.path_prefix }}
        INPUT_ARTEFACT_PATH: ${{ inputs.artefact_path }}
        INPUT_PURGE_ARTEFACT_PATH: ${{ inputs.purge_artefact_path }}
      run: |
        # Setup action/environment

        # Set input variables
        path_prefix="${INPUT_PATH_PREFIX}"
        artefact_path="${INPUT_ARTEFACT_PATH}"
        purge_artefact_path="${INPUT_PURGE_ARTEFACT_PATH}"

        # Verify path_prefix a valid directory path
        if [ ! -d "$path_prefix" ]; then
          echo 'Error: invalid path/prefix to project directory ❌'; exit 1
        fi

        # Output build heading
        echo '# 🐍 Python Build' >> "$GITHUB_STEP_SUMMARY"

        # Set build parameters/variables
        echo "Action triggered by: ${GITHUB_TRIGGERING_ACTOR}"
        datetime=$(date +'%Y-%m-%d-%H%M')
        echo "Build date and time stamp: $datetime"
        echo "datetime=$datetime" >> "$GITHUB_ENV"
        echo "datetime=${datetime}" >> "$GITHUB_OUTPUT"

        if [ "$purge_artefact_path" != "false" ] && \
          [ -n "$purge_artefact_path" ] && \
          [ -d "$path_prefix/$artefact_path" ]; then
          echo "Purging artefact output path prior to build ⚠️"
          echo "Path: $path_prefix/$artefact_path"
          rm -Rf "$path_prefix/$artefact_path"/*
        fi

    - name: 'Gather Python project metadata'
      id: python-metadata
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/python-project-metadata-action@773af91523f36df7964c315c5dc050f4883daab0 # v0.1.14
      with:
        path_prefix: "${{ inputs.path_prefix }}"

    # Catch this condition early in build process
    - name: 'Check project version matches pushed tags'
      # yamllint disable rule:line-length
      if: github.ref_type == 'tag' && steps.python-metadata.outputs.versioning_type != 'dynamic'
      uses: lfreleng-actions/python-project-tag-push-verify-action@0ddfb400a8b6f1178eabbe342c91938ecf1ab01e # v0.1.2
      # yamllint enable rule:line-length
      with:
        path_prefix: "${{ inputs.path_prefix }}"

    - name: 'Fetch tags to support dynamic versioning'
      # yamllint disable rule:line-length
      if: steps.python-metadata.outputs.versioning_type == 'dynamic' && github.ref_type != 'tag'
      shell: bash
      env:
        INPUT_PATH_PREFIX: ${{ inputs.path_prefix }}
      run: |
        # Fetch tags to support dynamic versioning
        # ...but NOT when a tag push triggered the build
        path_prefix="${INPUT_PATH_PREFIX}"
        git -C "$path_prefix" fetch --unshallow
        git -C "$path_prefix" fetch --tags origin ||\
        { echo "Error: git fetch --tags failed" >&2; exit 1; }
        echo "Dynamic versioning: fetched repository tags 💬" \
          >> "$GITHUB_STEP_SUMMARY"

    - name: 'Explicit build versioning'
      if: inputs.tag != ''
      shell: bash
      env:
        INPUT_TAG: ${{ inputs.tag }}
      run: |
        # Explicit build versioning
        echo "Explicit build versioning: $INPUT_TAG 💬" \
          >> "$GITHUB_STEP_SUMMARY"

    - name: 'Patch project versioning metadata'
      # Optionally patch Python project file to match requested build tag
      # Skip patching if skip_version_patch is true for dynamic versioning
      # Also if tag doesn't differ from project version
      # yamllint disable-line rule:line-length
      if: inputs.skip_version_patch != 'true' && inputs.tag != '' && env.python_project_version != inputs.tag && steps.python-metadata.outputs.versioning_type != 'dynamic'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/python-project-version-patch-action@72969b8a16d004366948e3e49b250aa0549c56fa # v0.1.6
      with:
        replacement_version: "${{ inputs.tag }}"
        path_prefix: "${{ inputs.path_prefix }}"

    - name: 'Setup Python'
      # yamllint disable-line rule:line-length
      uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # v6.0.0
      with:
        # yamllint disable-line rule:line-length
        python-version: "${{ steps.python-metadata.outputs.build_python_version }}"

    - name: 'Cache Python dependencies'
      uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830 # v4.3.0
      with:
        path: |
          ~/.cache/pip
          ~/.cache/pypoetry
          ~/.cache/pipenv
          .venv
          .tox
        # yamllint disable rule:line-length
        key: >-
          python-${{ runner.os }}-${{ steps.python-metadata.outputs.build_python_version }}-
          ${{ hashFiles('**/requirements*.txt', '**/pyproject.toml', '**/poetry.lock', '**/Pipfile*', '**/setup.py', '**/setup.cfg') }}
        restore-keys: |
          python-${{ runner.os }}-${{ steps.python-metadata.outputs.build_python_version }}-
          python-${{ runner.os }}-
        # yamllint enable rule:line-length

    - name: 'Install build dependencies'
      shell: bash
      run: |
        # Install build dependencies
        echo 'Installing Python build dependencies...'
        python -m pip install --disable-pip-version-check \
          -q --upgrade build packaging
        echo 'Build dependencies installed ✅'

    - name: "Build with TOX"
      # yamllint disable rule:line-length
      if: "${{ inputs.tox_build == 'true' }}"
      shell: bash
      env:
        INPUT_PATH_PREFIX: ${{ inputs.path_prefix }}
      run: |
        # Perform build with TOX
        echo "Building with tox: some inputs/options may be disregarded ⚠️"

        path_prefix="${INPUT_PATH_PREFIX}"
        if [ -f "$path_prefix/tox.ini" ]; then
          echo "TOX configuration file: $path_prefix/tox.ini"
          python -m pip install --disable-pip-version-check \
            -q --upgrade tox tox-gh-actions
          echo "Building with: tox --root \"$path_prefix\" -c \"$path_prefix\"/tox.ini -e build"
          if (tox --root "$path_prefix" -c "$path_prefix/tox.ini" -e build); then
            echo 'Build with TOX successful ✅'
          else
            echo 'Build with TOX failed ❌'; exit 1
          fi
        else
          echo 'Error: TOX configuration not found ❌'; exit 1
        fi

    - name: 'Build Python project'
      # yamllint enable rule:line-length
      if: "${{ inputs.tox_build != 'true' }}"
      shell: bash
      env:
        INPUT_PATH_PREFIX: ${{ inputs.path_prefix }}
        INPUT_ARTEFACT_PATH: ${{ inputs.artefact_path }}
      run: |
        # Build Python project
        path_prefix="${INPUT_PATH_PREFIX}"
        artefact_path="${INPUT_ARTEFACT_PATH}"
        if [ -f "$path_prefix/pyproject.toml" ] || \
        [ -f "$path_prefix/setup.py" ]; then
          if (python -m build --outdir \
            "$path_prefix/$artefact_path" \
            "$path_prefix"); then
            echo 'Build with Python module successful ✅'
          else
            echo 'Build with Python module failed ❌'; exit 1
          fi
        else
          echo 'Error: project definition file not found ❌'; exit 1
        fi

    - name: 'Build outputs/summary'
      shell: bash
      env:
        INPUT_PATH_PREFIX: ${{ inputs.path_prefix }}
        INPUT_ARTEFACT_PATH: ${{ inputs.artefact_path }}
      # yamllint disable rule:line-length
      run: |
        # Build outputs/summary
        path_prefix="${INPUT_PATH_PREFIX}"
        artefact_path="${INPUT_ARTEFACT_PATH}"
        echo "artefact_name=${{ env.python_project_name }}" >> "$GITHUB_OUTPUT"
        echo "artefact_path=$path_prefix/$artefact_path" \
          >> "$GITHUB_OUTPUT"
        echo "Artefact name: ${{ env.python_project_name }}"
        echo "Artefact path: $path_prefix/$artefact_path"
        python_version=$(python --version)
        echo "Build with Python $python_version successful ✅"
        echo "Build with $python_version successful ✅" >> "$GITHUB_STEP_SUMMARY"

    # Note: caution with sequencing of steps
    # Twine validation after attestations/signing causes failures
    # yamllint enable rule:line-length
    - name: 'Validate artefacts with Twine'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/python-twine-check-action@514f458fad2cfe506da1e472d2a68c4297fcbf94 # v0.1.1
      with:
        path_prefix: "${{ inputs.path_prefix }}"
        path: "${{ inputs.artefact_path }}"

    - name: 'Perform artefact attestations'
      # yamllint disable-line rule:line-length
      uses: actions/attest-build-provenance@977bb373ede98d70efdf65b84cb5f73e068dcc2a # v3.0.0
      if: "${{ inputs.attestations == 'true' }}"
      with:
        subject-path: "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}/*"

    - name: 'Add heading to separate signing from attestations'
      if: "${{ inputs.sigstore_sign == 'true' }}"
      shell: bash
      run: |
        # Add heading to separate signing from attestations
        echo '### Sigstore Signing ✍🏼' >> "$GITHUB_STEP_SUMMARY"

    # SigStore signing adds JSON files to the artefacts directory
    - name: 'Sign packages with SigStore'
      if: "${{ inputs.sigstore_sign == 'true' }}"
      # yamllint disable-line rule:line-length
      uses: sigstore/gh-action-sigstore-python@f7ad0af51a5648d09a20d00370f0a91c3bdf8f84 # v3.0.1
      env:
        package-path: "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"
      with:
        inputs: >-
          ./${{ inputs.path_prefix }}/${{ inputs.artefact_path }}/*.tar.gz
          ./${{ inputs.path_prefix }}/${{ inputs.artefact_path }}/*.whl

    - name: 'Upload build artefacts'
      if: "${{ inputs.artefact_upload == 'true' }}"
      # yamllint disable-line rule:line-length
      uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4.6.2
      with:
        name: "${{ env.python_project_name }}"
        path: "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"
        if-no-files-found: error
        overwrite: "${{ inputs.purge_artefact_path }}"
