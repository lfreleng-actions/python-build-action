---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# python-build-action
name: 'üêç Build Python Project'
description: 'Builds a Python Project'

inputs:
  # Optional
  artefact_name:
    # Useful when building for multiple platforms/architectures
    # Can be used to avoid uploading artefacts with conflicting names
    description: 'Custom name for uploaded artefacts (defaults to project name)'
    required: false
    # type: string
  artefact_path:
    description: 'Build artefacts will be output to this folder/directory'
    required: false
    # type: string
    default: 'dist'
  artefact_upload:
    description: 'Upload artefacts to GitHub once build completed'
    required: false
    # type: boolean
    default: 'true'
  purge_artefact_path:
    description: 'Purge artefact path prior to performing build'
    required: false
    # type: boolean
    default: 'false'
  tag:
    description: 'Explicit tag/version for this build (semantic)'
    required: false
    # type: string
  skip_version_patch:
    description: 'Skip version patching (support dynamic versioning)'
    required: false
    # type: boolean
    default: 'false'
  attestations:
    # Attestations should NOT be enabled for development builds
    description: 'Apply GitHub attestations to artefacts'
    required: false
    # type: boolean
    default: 'false'
  sigstore_sign:
    # Signing should NOT be enabled for development builds
    description: 'Sign build artefacts with Sigstore'
    required: false
    # type: boolean
    default: 'false'
  path_prefix:
    description: 'Directory location containing project code'
    required: false
    # type: string
    default: '.'
  tox_build:
    description: 'Attempt to use TOX to perform build'
    required: false
    # type: boolean
    default: 'false'
  clear_cache:
    description: 'Clear all Python dependency caches for this repository'
    required: false
    # type: boolean
    default: 'false'
  python_version:
    description: >-
      Override Python version for build (uses metadata detection if not set)
    required: false
    # type: string
  build_formats:
    description: 'Build formats: wheel, sdist, or both (default: both)'
    required: false
    # type: string
    default: 'both'
  auditwheel:
    description: 'Run auditwheel to repair wheels for manylinux compatibility'
    required: false
    # type: boolean
    default: 'false'
  manylinux_version:
    # Examples: manylinux2014, manylinux_2_28, manylinux_2_34, etc.
    description: 'Target manylinux version for auditwheel'
    required: false
    # type: string
    default: 'manylinux_2_34'
  make:
    description: 'Run make before building'
    required: false
    # type: boolean
    default: 'false'
  make_args:
    description: 'Arguments/flags sent to make command'
    required: false
    # type: string
    default: ''

outputs:
  build_python_version:
    description: 'Python version used to perform build (create artefacts)'
    value: "${{ steps.python_version.outputs.python_version }}"
  matrix_json:
    description: 'Project supported Python versions as JSON'
    value: ${{ steps.metadata.outputs.python_matrix_json }}
  artefact_name:
    description: 'Project name used for build artefacts'
    value: ${{ steps.build_summary.outputs.artefact_name }}
  artefact_path:
    description: 'Full path to build artefacts directory'
    value: ${{ steps.build_summary.outputs.artefact_path }}

runs:
  using: 'composite'
  steps:
    - name: 'Setup action/environment'
      shell: bash
      run: |
        set -euo pipefail
        # Setup action/environment

        # Set input variables
        path_prefix="${{ inputs.path_prefix }}"
        artefact_path="${{ inputs.artefact_path }}"
        purge_artefact_path="${{ inputs.purge_artefact_path }}"

        # Verify path_prefix a valid directory path
        if [ ! -d "$path_prefix" ]; then
          echo 'Error: invalid path/prefix to project directory ‚ùå'; exit 1
        fi

        # Output build heading
        echo '# üêç Python Build' >> "$GITHUB_STEP_SUMMARY"

        # Set build parameters/variables
        echo "Action triggered by: ${GITHUB_TRIGGERING_ACTOR}"
        datetime=$(date +'%Y-%m-%d-%H%M')
        echo "Build date and time stamp: $datetime"
        echo "datetime=$datetime" >> "$GITHUB_ENV"
        echo "datetime=${datetime}" >> "$GITHUB_OUTPUT"

        if [ "$purge_artefact_path" != "false" ] && \
          [ -n "$purge_artefact_path" ] && \
          [ -d "$path_prefix/$artefact_path" ]; then
          echo "Purging artefact output path prior to build ‚ö†Ô∏è"
          echo "Path: $path_prefix/$artefact_path"
          rm -Rf "$path_prefix/$artefact_path"/*
        fi

    - name: 'Gather Python project metadata'
      id: metadata
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/build-metadata-action@c8d6f8396301edd325ac90db463850048f5fe20c # v0.1.1
      with:
        path_prefix: "${{ inputs.path_prefix }}"
        output_format: summary
        include_environment: true
        use_version_extract: true
        verbose: true

    # Catch this condition early in build process
    - name: 'Check project version matches pushed tags'
      # yamllint disable rule:line-length
      if: github.ref_type == 'tag' && steps.metadata.outputs.python_versioning_type != 'dynamic'
      uses: lfreleng-actions/python-project-tag-push-verify-action@f38729e7497f1a86e2f2e034321ec162ddee1843 # v0.1.3
      # yamllint enable rule:line-length
      with:
        path_prefix: "${{ inputs.path_prefix }}"

    - name: 'Fetch tags to support dynamic versioning'
      # yamllint disable rule:line-length
      if: github.ref_type != 'tag' && steps.metadata.outputs.python_versioning_type == 'dynamic'
      shell: bash
      run: |
        set -euo pipefail
        # Fetch tags to support dynamic versioning
        # ...but NOT when a tag push triggered the build
        path_prefix="${{ inputs.path_prefix }}"
        git -C "$path_prefix" fetch --unshallow
        git -C "$path_prefix" fetch --tags origin ||\
        { echo "Error: git fetch --tags failed" >&2; exit 1; }
        echo "Dynamic versioning: fetched repository tags üí¨" \
          >> "$GITHUB_STEP_SUMMARY"

    - name: 'Explicit build versioning'
      if: inputs.tag != ''
      shell: bash
      run: |
        set -euo pipefail
        # Explicit build versioning
        echo "Explicit build versioning: ${{ inputs.tag }} üí¨" \
          >> "$GITHUB_STEP_SUMMARY"

    - name: 'Patch project versioning metadata'
      # Optionally patch Python project file to match requested build tag
      # Skip patching if skip_version_patch is true for dynamic versioning
      # Also skip patching if tag matches project version
      if: >-
        inputs.skip_version_patch != 'true' &&
        inputs.tag != '' &&
        steps.metadata.outputs.project_version != inputs.tag &&
        steps.metadata.outputs.python_versioning_type != 'dynamic'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/python-project-version-patch-action@00abe0079fb90e4dbec00e2bb1ad97407170fe7d # v0.1.7
      with:
        replacement_version: "${{ inputs.tag }}"
        path_prefix: "${{ inputs.path_prefix }}"

    - name: 'Determine Python version for build'
      id: python_version
      shell: bash
      run: |
        set -euo pipefail
        # Determine Python version for build
        if [ -n "${{ inputs.python_version }}" ]; then
          python_version="${{ inputs.python_version }}"
          echo "Using override Python version: $python_version üîß"
        else
          python_version="${{ steps.metadata.outputs.python_build_version }}"
          if [ -z "$python_version" ]; then
            echo "Error: Python version not available ‚ùå" >&2
            echo "Could not determine Python version from metadata or input" >&2
            exit 1
          fi
          echo "Using Python version from metadata: $python_version üí¨"
        fi
        echo "python_version=$python_version" >> "$GITHUB_OUTPUT"

    - name: 'Setup Python'
      # yamllint disable-line rule:line-length
      uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
      with:
        # yamllint disable-line rule:line-length
        python-version: "${{ steps.python_version.outputs.python_version }}"

    - name: 'Clear Python dependency caches'
      if: inputs.clear_cache == 'true'
      shell: bash
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # Clear Python dependency caches
        echo "Clearing Python dependency caches üóëÔ∏è"
        output="$(gh cache delete --all 2>&1)" || exit_code=$?
        if [ -z "${exit_code:-}" ]; then
          echo "Cache clearing completed ‚úÖ" >> "$GITHUB_STEP_SUMMARY"
        else
          # Cache clearing should not be fatal; minimal output to summary
          echo "Cache clearing was not successful üí¨" >> "$GITHUB_STEP_SUMMARY"
          # More detailed information goes to the console/log output
          echo "gh cache exit code: ${exit_code} üí¨"
          echo "$output"
        fi

    - name: 'Cache Python dependencies'
      uses: actions/cache@cdf6c1fa76f9f475f3d7449005a359c84ca0f306 # v5.0.3
      with:
        path: |
          ~/.cache/pip
          ~/.cache/pypoetry
          ~/.cache/pipenv
          .venv
          .tox
        # yamllint disable rule:line-length
        key: >-
          python-${{ runner.os }}-${{ steps.python_version.outputs.python_version }}-
          ${{ hashFiles('**/requirements*.txt', '**/pyproject.toml', '**/poetry.lock', '**/Pipfile*', '**/setup.py', '**/setup.cfg') }}
        restore-keys: |
          python-${{ runner.os }}-${{ steps.python_version.outputs.python_version }}-
          python-${{ runner.os }}-
        # yamllint enable rule:line-length

    - name: 'Install build dependencies'
      shell: bash
      run: |
        set -euo pipefail
        # Install build dependencies
        echo 'Installing Python build dependencies...'
        python -m pip install --disable-pip-version-check \
          -q --upgrade build packaging
        echo 'Build dependencies installed ‚úÖ'

    - name: 'Prepare make arguments'
      if: inputs.make == 'true'
      id: make_prep
      shell: bash
      run: |
        # Prepare make arguments
        args="${{ inputs.make_args }}"
        if [ -n "${{ inputs.path_prefix }}" ] && \
           [ "${{ inputs.path_prefix }}" != '.' ]; then
          args="-C \"${{ inputs.path_prefix }}\" $args"
        fi
        echo "make_args=$args" >> "$GITHUB_OUTPUT"

    - name: 'Conditionally run make'
      if: inputs.make == 'true'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/make-action@e07201ee8e3d1f34800f1c63f58415624a8c054c  # v0.1.3
      with:
        make_args: ${{ steps.make_prep.outputs.make_args }}

    - name: "Build with TOX"
      # yamllint disable rule:line-length
      if: inputs.tox_build == 'true'
      shell: bash
      run: |
        # Build with TOX
        set -euo pipefail
        echo "Building with tox: some inputs/options may be disregarded ‚ö†Ô∏è"

        path_prefix="${{ inputs.path_prefix }}"
        if [ -f "$path_prefix/tox.ini" ]; then
          echo "TOX configuration file: $path_prefix/tox.ini"
          python -m pip install --disable-pip-version-check \
            -q --upgrade tox tox-gh-actions
          echo "Building with: tox --root \"$path_prefix\" -c \"$path_prefix\"/tox.ini -e build"
          if (tox --root "$path_prefix" -c "$path_prefix/tox.ini" -e build); then
            echo 'Build with TOX successful ‚úÖ'
          else
            echo 'Build with TOX failed ‚ùå'; exit 1
          fi
        else
          echo 'Error: TOX configuration not found ‚ùå'; exit 1
        fi
      # yamllint enable rule:line-length

    - name: 'Build Python project'
      if: inputs.tox_build != 'true'
      shell: bash
      run: |
        set -euo pipefail
        # Build Python project
        path_prefix="${{ inputs.path_prefix }}"
        artefact_path="${{ inputs.artefact_path }}"
        build_formats="${{ inputs.build_formats }}"

        # Validate build_formats input
        case "$build_formats" in
          wheel|sdist|both)
            # Valid
            ;;
          *)
            echo "Error: Invalid build_formats value: '$build_formats' ‚ùå"
            echo "Valid values are: 'wheel', 'sdist', or 'both'"
            exit 1
            ;;
        esac

        # Determine build flags
        build_flags=""
        if [ "$build_formats" = "wheel" ]; then
          build_flags="--wheel"
        elif [ "$build_formats" = "sdist" ]; then
          build_flags="--sdist"
        fi

        if [ -f "$path_prefix/pyproject.toml" ] || \
        [ -f "$path_prefix/setup.py" ]; then
          if (python -m build $build_flags --outdir \
            "$path_prefix/$artefact_path" \
            "$path_prefix"); then
            echo 'Build with Python module successful ‚úÖ'
          else
            echo 'Build with Python module failed ‚ùå'; exit 1
          fi
        else
          echo 'Error: project definition file not found ‚ùå'; exit 1
        fi

    - name: 'Repair wheels with auditwheel'
      # yamllint disable-line rule:line-length
      if: inputs.auditwheel == 'true' && inputs.build_formats != 'sdist'
      shell: bash
      run: |
        set -euo pipefail
        # Repair wheels to manylinux format for PyPI compatibility
        path_prefix="${{ inputs.path_prefix }}"
        artefact_path="${{ inputs.artefact_path }}"

        # Check if there are any wheels to repair
        if ls "$path_prefix/$artefact_path"/*.whl 1> /dev/null 2>&1; then
          echo "Installing auditwheel..."
          python -m pip install auditwheel

          # Create temp directory for repaired wheels
          mkdir -p "$path_prefix/$artefact_path/wheelhouse"

          # Repair each wheel
          manylinux_version="${{ inputs.manylinux_version }}"
          echo "Using manylinux version: $manylinux_version"

          # Detect architecture for platform tag
          arch=$(uname -m)
          if [ "$arch" = "x86_64" ]; then
            platform_tag="${manylinux_version}_x86_64"
          elif [ "$arch" = "aarch64" ]; then
            platform_tag="${manylinux_version}_aarch64"
          else
            echo "‚ö†Ô∏è Unsupported architecture: $arch"
            echo "Supported architectures: x86_64, aarch64"
            echo "Attempting to use platform tag: ${manylinux_version}_${arch}."
            platform_tag="${manylinux_version}_${arch}"
          fi
          echo "Platform tag: $platform_tag"

          for wheel in "$path_prefix/$artefact_path"/*.whl; do
            echo "Repairing wheel: $(basename "$wheel")"

            # Show wheel info (informational only, don't fail on errors)
            auditwheel show "$wheel" || \
              echo "Note: auditwheel show failed for $(basename "$wheel")"

            # Attempt repair
            if auditwheel repair "$wheel" --plat "$platform_tag" \
                -w "$path_prefix/$artefact_path/wheelhouse"; then
              echo "‚úÖ Successfully repaired $(basename "$wheel")"
            else
              echo "‚ö†Ô∏è auditwheel repair failed for $(basename "$wheel")"
              echo "Will keep original build artefact unmodified"
              cp "$wheel" "$path_prefix/$artefact_path/wheelhouse/"
            fi
          done

          # Replace original wheels with repaired ones
          rm -f "$path_prefix/$artefact_path"/*.whl
          mv "$path_prefix/$artefact_path/wheelhouse"/*.whl \
            "$path_prefix/$artefact_path/"
          rmdir "$path_prefix/$artefact_path/wheelhouse"

          echo "Wheel repair completed ‚úÖ"
        else
          echo "No wheels found to repair"
        fi

    - name: 'Build outputs/summary'
      id: build_summary
      shell: bash
      # yamllint disable rule:line-length
      run: |
        set -euo pipefail
        # Build outputs/summary
        path_prefix="${{ inputs.path_prefix }}"
        artefact_path="${{ inputs.artefact_path }}"
        full_artefact_path="$path_prefix/$artefact_path"

        # Use custom artefact name if provided, otherwise use project name from
        # metadata, falling back to directory basename if that is unavailable
        artefact_name="${{ inputs.artefact_name }}"
        if [ -z "$artefact_name" ]; then
          project_name="${{ steps.metadata.outputs.project_name }}"
          if [ -z "$project_name" ]; then
            project_name=$(basename "$path_prefix")
            echo "Warning: project_name not found in metadata, using: $project_name" >&2
          fi
          artefact_name="$project_name"
        fi

        echo "artefact_name=$artefact_name" >> "$GITHUB_OUTPUT"
        echo "artefact_path=$full_artefact_path" >> "$GITHUB_OUTPUT"
        echo "Artefact name: $artefact_name"
        echo "Artefact path: $full_artefact_path"
        python_version=$(python --version)
        echo "Build with Python $python_version successful ‚úÖ"
        echo "Build with $python_version successful ‚úÖ" >> "$GITHUB_STEP_SUMMARY"

    # Note: caution with sequencing of steps
    # Twine validation after attestations/signing causes failures
    # yamllint enable rule:line-length
    - name: 'Validate artefacts with Twine'
      # yamllint disable-line rule:line-length
      uses: lfreleng-actions/python-twine-check-action@514f458fad2cfe506da1e472d2a68c4297fcbf94 # v0.1.1
      with:
        path_prefix: "${{ inputs.path_prefix }}"
        path: "${{ inputs.artefact_path }}"

    - name: 'Perform artefact attestations'
      # yamllint disable-line rule:line-length
      uses: actions/attest-build-provenance@00014ed6ed5efc5b1ab7f7f34a39eb55d41aa4f8 # v3.1.0
      if: inputs.attestations == 'true'
      with:
        subject-path: "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}/*"

    - name: 'Add heading to separate signing from attestations'
      if: inputs.sigstore_sign == 'true'
      shell: bash
      run: |
        set -euo pipefail
        # Add heading to separate signing from attestations
        echo '### Sigstore Signing ‚úçüèº' >> "$GITHUB_STEP_SUMMARY"

    # SigStore signing adds JSON files to the artefacts directory
    - name: 'Sign packages with SigStore'
      if: inputs.sigstore_sign == 'true'
      shell: bash
      # yamllint disable rule:line-length
      run: |
        set -euo pipefail
        # Build list of files to sign based on build_formats
        files_to_sign=()

        if [ "${{ inputs.build_formats }}" = "sdist" ] || [ "${{ inputs.build_formats }}" = "both" ]; then
          if ls "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"/*.tar.gz 1> /dev/null 2>&1; then
            files_to_sign+=("${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"/*.tar.gz)
          fi
        fi

        if [ "${{ inputs.build_formats }}" = "wheel" ] || [ "${{ inputs.build_formats }}" = "both" ]; then
          if ls "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"/*.whl 1> /dev/null 2>&1; then
            files_to_sign+=("${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"/*.whl)
          fi
        fi

        if [ ${#files_to_sign[@]} -eq 0 ]; then
          echo "‚ùå No files found to sign"
          exit 1
        fi

        echo "SIGSTORE_FILES<<EOF" >> "$GITHUB_ENV"
        printf '%s\n' "${files_to_sign[@]}" >> "$GITHUB_ENV"
        echo "EOF" >> "$GITHUB_ENV"
      # yamllint enable rule:line-length

    - name: 'Run SigStore signing'
      if: inputs.sigstore_sign == 'true'
      # yamllint disable-line rule:line-length
      uses: sigstore/gh-action-sigstore-python@a5caf349bc536fbef3668a10ed7f5cd309a4b53d # v3.2.0
      with:
        inputs: ${{ env.SIGSTORE_FILES }}

    - name: 'Upload build artefacts'
      if: inputs.artefact_upload == 'true'
      # yamllint disable-line rule:line-length
      uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
      with:
        name: "${{ steps.build_summary.outputs.artefact_name }}"
        path: "${{ inputs.path_prefix }}/${{ inputs.artefact_path }}"
        if-no-files-found: error
        overwrite: "${{ inputs.purge_artefact_path }}"
